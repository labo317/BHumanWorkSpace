# 3.3 模块和表示（Modules and Representations）

机器人控制程序通常由几个模块组成，每个模块执行特定的任务，如图像处理、自定位或行走。模块需要特定的输入并产生特定的输出(所谓的表示)。因此，它们必须以特定的顺序执行才能使整个系统正常工作。引入的模块框架简化了模块接口的定义，并自动确定了必须执行模块的顺序。它包括黑板、模块定义和可视化组件(参看10.1.4.5节)。

### 3.3.1 Blackboard

黑板是信息的中心存储器，即表示的中心存储器。每个进程都与它自己的blackboard实例相关联。如果一个进程中的模块需要由另一个进程中的模块提供的表示，则表示将通过进程间通信进行传输。黑板本身是一个映射，它将表示的名称与这些表示的引用计数实例相关联。它只包含相关流程中至少一个模块实际需要或提供的表示的条目。

### 3.3.2 模块定义（Module Definition）

模块的定义由三个部分组成:模块接口、模块的实际实现和允许实例化模块的语句。下面一个例子：

```cpp
MODULE(SimpleBallLocator, 
{,
    REQUIRES(BallPercept),
    REQUIRES(FrameInfo),
    PROVIDES(BallModel),
    DEFINES_PARAMETERS(
    {,
        (Vector2f)(5.f, 0.f)offset,
        (float)(1.1f)scale,
    }),
});
class SimpleBallLocator : public SimpleBallLocatorBase
{
    void update(BallModel &ballModel)
    {
        if (theBallPercept.wasSeen)
        {
            ballModel.position = theBallPercept.position * scale + offset;
            ballModel.wasLastSeen = theFrameInfo.frameTime;
        }
    }
} 
MAKE_MODULE(SimpleBallLocator, modeling);
```

模块接口定义模块的名称(例如SimpleBallLocator)、执行其任务所需的表示、模块提供的表示以及模块的参数，模块的值可以就地定义或从文件中加载。该接口基本上按照<ModuleName> base的命名模式为实际模块创建一个基类。模块的实际实现是一个派生自基类的类。它对黑板中所有必需的表示具有只读访问权(仅对那些表示具有只读访问权)，并且必须为提供的每个表示定义更新方法。它还继承所有参数。正如第3.3.3节中所述，模块可以预期，在调用任何提供程序方法之前，它们所需的所有表示都已更新。最后，MAKE MODULE语句允许实例化模块。它的第二个参数定义了一个类别，用于对模块配置进行更结构化的可视化(参看10.1.4.5节)。第二个参数还用于筛选可以在当前框架环境中加载的模块，即流程(cf. section . 3.2)。在过程认知中，认知基础结构、沟通、感知、建模和行为控制是可用的;在过程运动中，认知基础结构、运动控制和感知是可用的。可用类别的列表定义在各自流程(Src/Processes/Cognition)的主实现文件中。cpp和Src /流程/ Motion.cpp)。虽然模块接口通常是头文件的一部分，但是MAKE模块语句必须是实现文件的一部分。

MODULE是一个宏，它以参数的形式获取关于模块的所有信息，也就是说，模块之间用逗号分隔。宏忽略它的第二个和最后一个参数，因为按照惯例，这些参数用于打开和关闭大括号。这使得一些源代码格式化工具可以将定义缩进为一个块。目前，模块被限制在大括号之间最多80个定义。当宏被展开时，它会创建许多隐藏的功能。引用表示的每个条目确保在构建模块时在黑板中创建它，在解构模块时释放它。模块具有特定需求并提供特定表示的信息不仅用于为该模块生成基类，还可用于对提供者进行排序，主机PC可以请求这些信息。在主机PC上，信息可用于更改配置和可视化(参看10.1.4.5节)。

对于所提供的每个表示，可以确定执行时间(cf. section . 3.6.7)，并且可以将其发送到主机PC，甚至由主机更改。如果不需要后者，则可以使用无需修改的provide代替。如果存在MesssageID id\<representation>，也可以记录该表示。

如果提供的表示定义了无参数方法绘制，则在更新表示之后将调用该方法。该方法旨在使用第3.6.3节中描述的技术来可视化表示。如果表示定义了一个无参数的方法verify，那么该方法也将在表示更新之后的Debug和development build中被调用。验证方法应该包含检查表示的内容是否可信的断言。只有在表示本身中定义了这两个方法，而不是从其基类继承它们时，才会调用它们。

### 3.3.3 配置提供者(Configuring Providers)

由于模块可以提供不止一种表示形式，因此必须在提供程序级别上按格式进行配置。对于每个表示，可以选择哪个模块提供它，或者根本不提供它。通常，从文件Config/ scenario /\<scenario>/modules中读取配置。cfg，但当机器人使用命令mr (cf. section . 10.1.6.3)与主机PC进行调试连接时，也可以交互式地更改cfg。
配置没有指定执行提供程序的顺序。这个序列是在运行时自动确定的，它基于这样一个规则:提供者所需的所有表示必须在之前由其他提供者提供，即那些提供者必须更早地执行。
在某些情况下要求一定是由前一个模块提供其他任何形式是由相同的模块,例如,当模块的主要任务是执行的更新方法表示,和其他更新方法依赖结果计算在第一个。这种情况可以通过在同一个模块中同时要求和提供表示来实现。

### 3.3.4 伪模块默认（Pseudo-Module default）

在机器人控制软件的开发过程中，有时需要简单地去激活某个提供者或模块。正如上面提到的,它总是可以决定不提供一定的表征,即关闭所有供应商生成表示。然而,通常不提供一定表示使组提供者inconsis帐篷,因为其他供应商依赖表示,所以他们会停用。这具有级联效应。在许多情况下，最好能够取消对提供者的激活，而不影响模块之间的依赖关系。这就是模块默认设计的目的。它是一个人工构造——所以不是一个真正的模块——它可以提供相同过程中任何模块都可以提供的所有表示。它永远不会改变任何表示形式——因此它们基本上保持初始状态——但它将确保它们的存在，从而解决所有依赖关系。然而，就功能而言，使用默认值的配置永远不会完成，因此不应该在实际游戏中使用。

### 3.3.5 参数化模块（Parameterizing Modules）

模块通常需要一些参数才能正常工作。这些参数也可以在模块的接口描述中定义。参数的行为类似于受保护的类成员，可以以相同的方式访问。此外，还可以使用get参数:\<ModuleName>或vd参数:\<ModuleName> (cf. section . 10.1.6.3)在控制台操作它们。

有两种不同的参数初始化方法。在硬编码方法中，初始化值作为c++源文件的一部分指定。它们是使用define PARAMETERS宏定义的。此宏用于在开发过程中可能更改，但在开发之后不会再更改的参数。相反，可加载参数被初始化为在模块创建时从配置文件加载的值，即初始化值在源文件中没有指定。这些参数是使用loadparameters宏定义的。默认情况下，参数是从与模块同名的文件加载的，但从小写字母2和扩展名.cfg开始。例如，如果一个模块名为SimpleBallLocator，那么它的配置文件就是simpleballlocation .cfg。这个文件可以放在通常配置文件搜索路径的任何位置(参看2.9节)。还可以将自定义名称作为参数传递给模块基类的构造函数，从而为模块的配置文件分配自定义名称。

模块定义中只能使用定义参数或加载参数。它们都只能使用一次。它们的语法遵循生成的流式类的定义(参见3.4.4节)。参数可以有任何数据类型，只要它是流式的(参看3.4.3节)。

